
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://www.yujin123.cn/%E6%A1%86%E6%9E%B6%E7%AF%87/React/%E6%B7%B1%E5%85%A5React%E5%8E%9F%E7%90%86II%EF%BC%9A%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E6%A8%A1%E5%9E%8B/">
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.17">
    
    
      
        <title>引言 - 余烬的个人博客</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.7e37652d.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="余烬的个人博客" class="md-header__button md-logo" aria-label="余烬的个人博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            余烬的个人博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              引言
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="余烬的个人博客" class="md-nav__button md-logo" aria-label="余烬的个人博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    余烬的个人博客
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    浏览器篇
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            浏览器篇
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%20I%EF%BC%9A%E4%BB%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%E5%88%B0%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    深入浏览器引擎 I：从多进程架构到渲染引擎
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%20II%EF%BC%9AHTML%20%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B%E2%80%94%E2%80%94%E4%BB%8E%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%20DOM%20%E6%9E%84%E5%BB%BA/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    深入浏览器引擎 II：HTML 解析全流程——从字节流到 DOM 构建
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%20III%EF%BC%9AChromium%E5%88%86%E5%B1%82%E5%90%88%E6%88%90%20vs%20Firefox%20WebRender%E7%9A%84GPU%E9%9D%A9%E5%91%BD/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    深入浏览器引擎 III：Chromium分层合成 vs Firefox WebRender的GPU革命
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%20IV%EF%BC%9AV8%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    深入浏览器引擎 IV：V8 垃圾回收机制
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    深入JavaScript篇
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            深入JavaScript篇
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%B7%B1%E5%85%A5JavaScript%E7%AF%87/%E6%B7%B1%E5%85%A5JavaScript%20I%EF%BC%9A%E4%BB%8E%E8%A7%84%E8%8C%83%E4%B8%AD%E7%9C%8BJavaScript%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%88%B6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    深入JavaScript I：从规范中看JavaScript运行时机制
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">引言</h1>
<p>在浏览器单线程模型中，JavaScript 执行、垃圾回收（GC）、用户交互响应与 UI 渲染<strong>竞争同一主线程资源</strong>。用户屏幕以 60Hz 刷新率运行时，主线程必须在 16.6ms 内完成每帧渲染任务——一旦 JavaScript 执行超时，将触发<strong>渲染帧丢失（Dropped Frames）</strong>，导致页面卡顿甚至交互冻结。
React 作为数据驱动型 UI 框架，面临核心挑战：
1. <strong>资源瓶颈</strong>：组件树深度遍历（如万级节点 diff）可能阻塞主线程
2. <strong>优先级冲突</strong>：用户交互（点击/输入）需即时响应，数据加载可延迟
3. <strong>任务竞争</strong>：渲染更新与 JS 逻辑共享有限计算资源
为了解决这些问题，React 设计实现了一个调度系统和优先级模型，核心思路是通过<strong>时间切片</strong>来将长任务拆分成多个小任务执行，避免阻塞渲染帧，此外基于<strong>优先级模型</strong>对任务根据紧急程度来设置优先级，以便优先处理紧急的任务，如用户输入。</p>
<h1 id="_2">调度系统的实现</h1>
<h2 id="_3">抽象接口</h2>
<p>React 作为构建用户界面的 JavaScript 库，其协调器（Reconciler）需要处理诸如状态更新、组件挂载/卸载、副作用执行等多样化的任务。这些任务虽然在触发场景和执行逻辑上存在显著差异，但 React 并未为每类任务单独设计调度逻辑，而是将任务抽象成一个特定的 Task 接口，<strong>所有需要被调度系统执行的任务都需要符合该接口的规范。</strong></p>
<pre><code class="language-typescript">type Task = {
  id: number, // 任务唯一标识
  callback: Callback | null, // 回调
  priorityLevel: PriorityLevel, // 优先级
  startTime: number, // 计划开始时间
  expirationTime: number, // 过期时间
  sortIndex: number, // 在任务队列中排序使用，timerQueue取自startTime，taskQueue取自expirationTime
  isQueued?: boolean, // 是否已经在任务队列中
};
</code></pre>
<p>我们称实现 Task 接口的 js 对象为 task，task 是调度系统的最小调度单元。从 Task 可以看出，每个 task 都有一个 id、callback、priorityLevel、startTime 等字段，每个字段都有各自的作用，例如调度系统执行 task 最终执行的其实是 <code>task.callback</code>, priorityLevel 记录了该 task 的优先级。</p>
<h2 id="_4">双任务队列设计与最小堆</h2>
<h3 id="_5">优先级队列</h3>
<p>现代前端框架的调度系统需要统筹异步任务的优先级与执行时机。传统单队列（FIFO）结构无法满足差异化调度需求，因此主流方案采用<strong>优先级队列</strong> （Priority Queue）实现任务排序。React 调度器在此基础上创新性地引入<strong>双队列架构</strong> ，通过两个基于小顶堆（Min-Heap）实现的优先级队列协同工作：
- <strong>taskQueue</strong> （立即执行队列）：存储已就绪的高优任务（如用户交互），基于<strong>过期时间</strong> （expirationTime）排序。过期时间越早（数值越小），优先级越高，队列顶部始终是当前最紧急任务
- <strong>timerQueue</strong> （延迟执行队列）：存储尚未就绪的低优任务（如数据预加载），基于<strong>计划时间</strong> （startTime）排序。计划时间越早（数值越小），触发调度的时机越快
当任务被创建时，React会根据 <code>task.startTime</code> 来决定存储到哪个队列中:
- 若 <code>task.startTime&gt;currentTime</code>，低优先任务，存储到 timerQueue 延后执行。
- 若 <code>task.startTime&lt;=currentTime</code>，高优先级任务，存储到 taskQueue 尽快执行。
<strong>React 调度系统只会执行 taskQueue 中的任务，并且会不时地检查 timerQueue 队列，如果有 <code>task.startTime&lt;=currentTime</code> 的任务，会被提升到 taskQueue 队列中。</strong></p>
<pre><code class="language-typescript">function advanceTimers(currentTime: number) {
  // 检查timerQueue是否有过期任务，并将其移动到taskQueue中
  let timer = peek(timerQueue);
  while (timer !== null) {
    if (timer.callback === null) {
      // 任务被取消，出队
      pop(timerQueue);
    } else if (timer.startTime &lt;= currentTime) {
      // 任务过期，移动到taskQueue中尽快执行
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
      if (enableProfiling) {
        markTaskStart(timer, currentTime);
        timer.isQueued = true;
      }
    } else {
      return;
    }
    timer = peek(timerQueue);
  }
}
</code></pre>
<p><code>advanceTimers</code> 专门负责检查 timerQueue 队列是否有过期的任务，如果有则移动到 taskQueue 中。
需要注意的是，<strong>虽然 timerQueue 和 taskQueue 我们称为队列，但是本质上两者都是以最小堆的形式存在。</strong> <code>peek</code> 函数返回的是最小堆的堆顶，timerQueue 和 taskQueue 都采用 sortIndex 字段来决定元素在堆中的位置，但是两者 sortIndex 字段的取值不同，timerQueue 取自 startTime，taskQueue 取自 expirationTime，即 <strong>timerQueue 越前面的元素 startTime 越小，需要越早执行，而 taskQueue 越前面的元素过期时间越长，越需要尽快执行。</strong>
在 advanceTimers 函数中不断取出（不出堆）堆顶，每次遇到过期任务就从堆中 <code>pop</code> 堆顶并 <code>push</code> 到 taskQueue 中，不断重复此操作，直到堆为空或者堆顶计划开始时间大于当前时间。
如果堆顶计划开始时间大于当前时间，由于最小堆<strong>堆顶最小</strong>的特性，后面的元素的计划开始时间都必然大于堆顶元素的计划开始时间，也就是说后面的元素也必然没有过期，因此直接 <code>return</code> 退出函数。</p>
<h3 id="_6">最小堆</h3>
<p><strong>堆（Heap）</strong> 是一种特殊的树形数据结构，通常是一个 <strong>完全二叉树（Complete Binary Tree）</strong> ，它满足以下性质：
- <strong>父节点与子节点之间满足堆序关系</strong> ：
    - 在 <strong>最大堆（Max Heap）</strong> 中，父节点的值总是大于或等于其子节点的值。
    - 在 <strong>最小堆（Min Heap）</strong> 中，父节点的值总是小于或等于其子节点的值。
下面是一个最小堆的例子</p>
<pre><code>    1
   / \
  2   3
 / \
4   5
</code></pre>
<p>虽然堆是树形结构，但是实际使用时也可以用层级排序的数组表示，此时堆具有完全二叉树的规律：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>根节点</td>
<td>0</td>
</tr>
<tr>
<td>左子节点</td>
<td>i*2 + 1</td>
</tr>
<tr>
<td>右子节点</td>
<td>i*2 + 2</td>
</tr>
<tr>
<td>父节点</td>
<td>floor((i-1)/2) 或 (i-1) &gt;&gt;&gt; 1</td>
</tr>
<tr>
<td>在完全二叉树中，除了最后一层外每个节点都有两个子节点，那么第 k （从 0 开始）层的节点数就是 <code>2^k - 1</code>，第 k （从 0 开始）层第 m （从 0 开始）个节点索引 i 就是 <code>2^k - 1 + m</code>，那么其左子节点在第 k+1 层第 2 m 个节点，那么就是：</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>2^(k+1) - 1 + 2m = 2(2^k + m) - 1 = 2(i + 1) - 1 = 2i + 1
</code></pre>
<p>右子节点只要在左子节点基础上加 1 就行了是，即 <code>2i + 2</code>。同时也可以反推会父节点下标 i，推导过程略，有兴趣可以自行查询。
堆有三个重要的操作：
- peek：返回堆顶
- Insert/push：插入元素
- pop：取出堆顶</p>
<pre><code class="language-typescript">export function peek&lt;T: Node&gt;(heap: Heap&lt;T&gt;): T | null {
  return heap.length === 0 ? null : heap[0];
}
</code></pre>
<p>peek 操作时间复杂度是 O (1)，而插入元素为了保持堆序需要执行<strong>上浮</strong>，同理，取出堆顶后为了保持堆序需要执行<strong>下沉</strong>。
所谓的<strong>上浮是指元素插入到末尾后，通过不断与父节点比较交换，从而保持原有堆序的效果的操作。</strong></p>
<pre><code class="language-typescript">export function push&lt;T: Node&gt;(heap: Heap&lt;T&gt;, node: T): void {
  const index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
function siftUp&lt;T: Node&gt;(heap: Heap&lt;T&gt;, node: T, i: number): void {
  let index = i;
  while (index &gt; 0) {
    const parentIndex = (index - 1) &gt;&gt;&gt; 1;
    const parent = heap[parentIndex];
    if (compare(parent, node) &gt; 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      // The parent is smaller. Exit.
      return;
    }
  }
}
</code></pre>
<p><strong>下沉则是指在堆弹出堆顶后，将堆最后一个元素移动到队头位置，此时此元素作为堆顶，然后不断将其与左右子节点比较交换，最后保持原有堆序的操作。</strong></p>
<pre><code class="language-typescript">export function pop&lt;T: Node&gt;(heap: Heap&lt;T&gt;): T | null {
  if (heap.length === 0) {
    return null;
  }
  const first = heap[0];
  const last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    siftDown(heap, last, 0);
  }
  return first;
}

function siftDown&lt;T: Node&gt;(heap: Heap&lt;T&gt;, node: T, i: number): void {
  let index = i;
  const length = heap.length;
  const halfLength = length &gt;&gt;&gt; 1;
  while (index &lt; halfLength) {
    const leftIndex = (index + 1) * 2 - 1;
    const left = heap[leftIndex];
    const rightIndex = leftIndex + 1;
    const right = heap[rightIndex];

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) &lt; 0) {
      if (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // Neither child is smaller. Exit.
      return;
    }
  }
}
</code></pre>
<p>上浮和下沉两者最坏情况下的时间复杂度都是 O (logn)，这使得堆的插入和弹出都非常高效，适用于需要频繁插入的场景。
如果采用传统队列（FIFO）+ 二分搜索的方式实现任务队列，二分搜索的时间复杂度是 O(logn)，但是每次插入都会导致插入位置后面所有的元素移动后一位，这使得时间复杂度会退化至 O (n)。同理，每次弹出队头元素都会使后面的元素向前移动一位，时间复杂度也是 O (n)，而最小堆上浮和下沉都是通过交换节点实现的，并且上浮或下沉在最坏的情况下也只要进行 logn 次交换，因此每次平均时间复杂度是 O (logn)，性能更好，更适合这种频繁插入、弹出的操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>最小堆</th>
<th>传统排序队列（FIFO）</th>
</tr>
</thead>
<tbody>
<tr>
<td>取最小值</td>
<td>O (1)</td>
<td>O (1)</td>
</tr>
<tr>
<td>弹出最小值</td>
<td>O (logn)</td>
<td>O (n)</td>
</tr>
<tr>
<td>插入元素</td>
<td>O (logn)</td>
<td>O (n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O (n)</td>
<td>O (n)</td>
</tr>
</tbody>
</table>
<h2 id="_7">执行的时机</h2>
<p>调度任务会临时存储在双队列中，最终总归是要执行的，而执行的时机非常重要。我们知道浏览器运行时底层是由一个事件循环机制实现异步的，异步任务也分为微任务和宏任务，微任务优先级更高，每个事件循环周期内都会执行完所有微任务，而宏任务优先级较低，一个事件循环周期只执行一个宏任务,，而 React 调度任务主要是在宏任务中执行的。</p>
<pre><code class="language-typescript">function unstable_scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: Callback,
  options?: {delay: number},
): Task {
  var currentTime = getCurrentTime();

  var startTime;
  if (typeof options === 'object' &amp;&amp; options !== null) {
    var delay = options.delay;
    if (typeof delay === 'number' &amp;&amp; delay &gt; 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      // Times out immediately
      timeout = -1;
      break;
    case UserBlockingPriority:
      // Eventually times out
      timeout = userBlockingPriorityTimeout;
      break;
    case IdlePriority:
      // Never times out
      timeout = maxSigned31BitInt;
      break;
    case LowPriority:
      // Eventually times out
      timeout = lowPriorityTimeout;
      break;
    case NormalPriority:
    default:
      // Eventually times out
      timeout = normalPriorityTimeout;
      break;
  }

  var expirationTime = startTime + timeout;

  var newTask: Task = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };
  if (enableProfiling) {
    newTask.isQueued = false;
  }

  if (startTime &gt; currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
    if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) {
      // All tasks are delayed, and this is the task with the earliest delay.
      if (isHostTimeoutScheduled) {
        // Cancel an existing timeout.
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      // Schedule a timeout.
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    if (enableProfiling) {
      markTaskStart(newTask, currentTime);
      newTask.isQueued = true;
    }
    // Schedule a host callback, if needed. If we're already performing work,
    // wait until the next time we yield.
    if (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback();
    }
  }

  return newTask;
}
</code></pre>
<p><code>Unstable_scheduleCallback</code> 函数是 React 暴露给外层使用的创建调度任务的 API，正如我们前面所说的，<code>Unstable_scheduleCallback</code> 函数会根据优先级（priorityLevel）来确定计划开始时间（startTime），并通过判断计划开始时间来决定将任务存储在 timerQueue 还是 taskQueue 中，并且会执行不同的操作。</p>
<pre><code class="language-mermaid">graph TD
    A[创建新任务] --&gt; B{startTime &gt; currentTime?}
    B --&gt;|是| C[加入timerQueue]
    B --&gt;|否| D[加入taskQueue]
    C --&gt; E[设置hostTimeout]
    D --&gt; F[requestHostCallback]
    E --&gt;|超时| G[advanceTimers]
    G --&gt; H[迁移到taskQueue]
    H --&gt; F
</code></pre>
<p>根据前面的代码分析，任务执行的关键在于 <code>requestHostCallback</code> 函数和 <code>requestHostTimeout</code> 函数。
首先来看 <code>requestHostTimeout</code> 和 <code>handleTimeout</code>。<code>requestHostTimeout</code> 函数本质上是对 setTimeout 的封装。</p>
<pre><code class="language-typescript">// 捕获对本地API的本地引用，以防polyfill覆盖它
const localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
function requestHostTimeout(
  callback: (currentTime: number) =&gt; void,
  ms: number,
) {
 // 保存定时器id，以便后面可以取消时可以使用
  taskTimeoutID = localSetTimeout(() =&gt; {
    callback(getCurrentTime());
  }, ms);
}
</code></pre>
<p>关键在于 <code>handleTimeout</code> 函数，定时器到期时会执行此函数。</p>
<pre><code class="language-typescript">function handleTimeout(currentTime: number) {
  isHostTimeoutScheduled = false; // 标记当前没有定时器执行调度任务
  advanceTimers(currentTime); // 检查timerQueue是否有过期任务

  if (!isHostCallbackScheduled) { // 如果任务队列没有被调度执行
    if (peek(taskQueue) !== null) { // taskQueue不为空
       // 执行调度，同时标记
      isHostCallbackScheduled = true;
      requestHostCallback();
    } else {
      // 如果taskQueue是空的，则直接取timerQueue堆顶调度定时器延迟执行
      const firstTimer = peek(timerQueue);
      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}
</code></pre>
<p>在 <code>handleTimeout</code> 函数中可以看出，其最终执行的也是 <code>requestHostCallback</code> 函数，所以前面本质上只是使用了定时器延迟执行了 requestHostCallback 函数。接下来，我们重点关注 <code>requestHostCallback</code> 函数。</p>
<pre><code class="language-typescript">function requestHostCallback() {
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    schedulePerformWorkUntilDeadline();
  }
}
</code></pre>
<p><code>requestHostCallback</code> 函数很短，核心逻辑只有 <code>isMessageLoopRunning</code> 标志和 <code>schedulePerformWorkUntilDeadline</code> 函数调用。</p>
<pre><code class="language-typescript">let schedulePerformWorkUntilDeadline;
if (typeof localSetImmediate === 'function') {
  schedulePerformWorkUntilDeadline = () =&gt; {
    localSetImmediate(performWorkUntilDeadline);
  };
} else if (typeof MessageChannel !== 'undefined') {
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = () =&gt; {
    port.postMessage(null);
  };
} else {
  schedulePerformWorkUntilDeadline = () =&gt; {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
}
</code></pre>
<p><code>schedulePerformWorkUntilDeadline</code> 和前面的 <code>localSetTimeout</code> 函数一样，都是对原生 API 的封装，<code>SchedulePerformWorkUntilDeadline</code> 会根据不同的环境采用不同的 API：
1. Node 或者 IE 浏览器环境下，使用 <code>setImmediate</code> 函数。
2. DOM 或者 Worker 环境下，使用 <code>MessageChannel</code>。
3. 使用 <code>setTimeout</code> 进行兜底，因为 <code>setTimeout</code> 在绝大多数环境和旧浏览器中都具有良好的兼容性。
React 在 DOM 环境下优先使用 MessageChannel 而不是直接使用 setTimeout，这是因为在 <a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers">HTML 规范</a>中，嵌套 5 次以上的 <code>setTimeout(..., 0)</code> 强制 4ms 最小延迟，并且相较于 setTimeout，MessageChannel 不仅同样具有良好的兼容性，而且延迟更低。</p>
<blockquote>
<p>Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.</p>
</blockquote>
<h2 id="_8">时间切片</h2>
<p>React 创新性地引入了时间切片特性，所谓的时间切片是指将长任务拆分成多个小任务间隔性地执行，从而避免长时间地阻塞主线程。时间切片是一种非常有效的优化长任务的方式。由于微任务和同步任务具有阻塞性，会占用主线程阻塞 UI 渲染，因此可以看到 React 采用 MessageChannel 和 setTimeout 宏任务来避免阻塞。</p>
<blockquote>
<p>注意：Nodejs 中的事件循环机制和浏览器中的有所不同，因此setImmediate 不能以宏任务/微任务的视角来看待，但是使用方式如何，其目的都是为了避免阻塞。</p>
</blockquote>
<p><code>performWorkUntilDeadline</code> 是时间切片的入口函数，从 <code>schedulePerformWorkUntilDeadline</code> 函数中可以看出， <code>schedulePerformWorkUntilDeadline</code> 针对不同环境采用对应的异步 API 来调用 <code>performWorkUntilDeadline</code> 函数，接下来，我们继续关注 <code>performWorkUntilDeadline</code>。</p>
<pre><code class="language-typescript">const performWorkUntilDeadline = () =&gt; {
  if (enableRequestPaint) {
    needsPaint = false;
  }
  if (isMessageLoopRunning) {
    const currentTime = getCurrentTime();
    // Keep track of the start time so we can measure how long the main thread
    // has been blocked.
    startTime = currentTime;

    // If a scheduler task throws, exit the current browser task so the
    // error can be observed.
    //
    // Intentionally not using a try-catch, since that makes some debugging
    // techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will
    // remain true, and we'll continue the work loop.
    let hasMoreWork = true;
    try {
      hasMoreWork = flushWork(currentTime);
    } finally {
      if (hasMoreWork) {
        // If there's more work, schedule the next message event at the end
        // of the preceding one.
        schedulePerformWorkUntilDeadline();
      } else {
        isMessageLoopRunning = false;
      }
    }
  }
};
</code></pre>
<p><code>performWorkUntilDeadline</code> 函数通过调用 <code>flushWork</code> 函数去执行调度任务，这里有一个重要的逻辑就是 <code>hasMoreWork</code>，它标志着任务队列是否执行完毕，如果没有执行完，那么就继续再调用 <code>schedulePerformWorkUntilDeadline</code> 函数去异步调用自身。</p>
<pre><code class="language-typescript">function flushWork(initialTime: number) {
  // ... 省略部分代码
  // We'll need a host callback the next time work is scheduled.
  isHostCallbackScheduled = false;
  if (isHostTimeoutScheduled) {
    // We scheduled a timeout but it's no longer needed. Cancel it.
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  try {
      return workLoop(initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}
</code></pre>
<p><code>flushWork</code> 下一步调用 <code>workLoop</code> 函数，这里需要注意在 <code>isHostCallbackScheduled</code> 和 <code>isPerformingWork</code> 两个标志的设置。</p>
<pre><code class="language-typescript">function workLoop(initialTime: number) {
  let currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (!enableAlwaysYieldScheduler) {
      if (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
        // This currentTask hasn't expired, and we've reached the deadline.
        break;
      }
    }
    // $FlowFixMe[incompatible-use] found when upgrading Flow
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      currentTask.callback = null;
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      currentPriorityLevel = currentTask.priorityLevel;
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      if (enableProfiling) {
        // $FlowFixMe[incompatible-call] found when upgrading Flow
        markTaskRun(currentTask, currentTime);
      }
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback === 'function') {
        // If a continuation is returned, immediately yield to the main thread
        // regardless of how much time is left in the current time slice.
        // $FlowFixMe[incompatible-use] found when upgrading Flow
        currentTask.callback = continuationCallback;
        if (enableProfiling) {
          // $FlowFixMe[incompatible-call] found when upgrading Flow
          markTaskYield(currentTask, currentTime);
        }
        advanceTimers(currentTime);
        return true;
      } else {
        if (enableProfiling) {
          // $FlowFixMe[incompatible-call] found when upgrading Flow
          markTaskCompleted(currentTask, currentTime);
          // $FlowFixMe[incompatible-use] found when upgrading Flow
          currentTask.isQueued = false;
        }
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
        advanceTimers(currentTime);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
    if (enableAlwaysYieldScheduler) {
      if (currentTask === null || currentTask.expirationTime &gt; currentTime) {
        // This currentTask hasn't expired we yield to the browser task.
        break;
      }
    }
  }
  // Return whether there's additional work
  if (currentTask !== null) {
    return true;
  } else {
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
</code></pre>
<p>从代码中可以看出 <code>workLoop</code> 就是 React 任务调度执行的最终执行函数了，它最终执行的是 <code>task.callback</code>。通过 while 不断取出 taskQueue 堆顶任务执行。
while 循环中有一个中断分支，其中的 <code>enableAlwaysYieldScheduler</code> 是用于测试的，生产环境通常为false。<code>currentTask.expirationTime &gt; currentTime</code> 则是判断当前任务是否未过期，如果当前任务未过期，那么就理解中断循环。中断的另一个因素是 <code>shouldYieldToHost</code> 函数， <code>shouldYieldToHost</code> 函数主要是用于判断执行时间是否过长（即产生长任务），<code>shouldYieldToHost</code> 函数是实现时间切片的关键。</p>
<pre><code class="language-typescript">export const frameYieldMs = 5;

let frameInterval = frameYieldMs;
let startTime = -1;

function shouldYieldToHost(): boolean {
  // ... 省略部分代码
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed &lt; frameInterval) {
    // The main thread has only been blocked for a really short amount of time;
    // smaller than a single frame. Don't yield yet.
    return false;
  }
  // Yield now.
  return true;
}
</code></pre>
<p>可以看到，<code>shouldYieldToHost</code> 函数的作用是比较 <code>getCurrentTime () - startTime</code>，判断当前时间距离开始时间是否超过了 <code>frameInterval</code>，也就是 <code>5 ms</code>，如果超过了这个时间 <code>shouldYieldToHost</code> 就会返回 <code>false</code>，从而中断 <code>workLoop</code> 函数中的循环，即<strong>中断</strong>任务队列的执行。
在 <code>while</code> 循环结束后，React 会检查是否存在未完成的任务，如果有就返回 <code>true</code>，<code>performWorkUntilDeadline</code> 将其存储为 <code>hasMoreWork</code>，并重新执行 <code>schedulePerformWorkUntilDeadline</code>，从而再次异步调用 <code>workLoop</code>，此时第一个未被完成的任务就是 taskQueue 的堆顶，会被重新执行，这就实现了任务执行的<strong>恢复</strong>。通过这样一个巧妙地设计，React 实现了时间切片来改善长任务的阻塞问题。</p>
<pre><code class="language-mermaid">sequenceDiagram
    Scheduler-&gt;&gt;+Browser: 请求调度 (requestHostCallback)
    Browser-&gt;&gt;+Scheduler: 执行任务 (performWorkUntilDeadline)
    Scheduler-&gt;&gt;Scheduler: workLoop(hasTimeRemaining, initialTime)
    Scheduler-&gt;&gt;Task: 执行任务单元 (performTask)
    Scheduler-&gt;&gt;Browser: 检查剩余时间 (shouldYield)
    alt 时间充足
        Scheduler-&gt;&gt;Task: 继续执行
    else 时间不足
        Scheduler-&gt;&gt;Browser: 暂停并请求后续调度
    end
</code></pre>
<h1 id="_9">优先级模型</h1>
<pre><code class="language-mermaid">graph TD
    A[ImmediatePriority] --&gt;|最高| B[UserBlockingPriority]
    B --&gt; C[NormalPriority]
    C --&gt; D[LowPriority]
    D --&gt;|最低| E[IdlePriority]
</code></pre>
<ul>
<li>
<p><strong>紧急升级</strong>：用户交互触发的自动优先级提升</p>
</li>
<li>
<p><strong>饥饿防护</strong>：低优先级任务等待超时后的自动升级</p>
</li>
<li>
<p><strong>过渡更新</strong>：<code>startTransition</code> API 的优先级控制原理</p>
</li>
</ul>
<h2 id="settransition">setTransition</h2>
<h3 id="transition">过渡更新(Transition)原理</h3>
<ul>
<li>
<p><code>startTransition</code> 的实现机制</p>
</li>
<li>
<p>过渡标记在调度系统的传播</p>
</li>
<li>
<p>可中断渲染的边界控制</p>
</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
    
  </body>
</html>