# 引言

说到性能优化，网上有着大量相关的技术文章，但是大多数都是零零散散地总结了一堆前端性能优化的方法，很少有能将前端性能问题串联起来分析的文章，而将前端性能问题的本质暴露出来并形成优化模型的就更少了。

# 前端性能优化模型
## 构建层（前端工程化）

当前前端应对大型项目基本都采用前端工程化的形式进行开发，而不再是传统的 HTML、CSS 和 JS 三件套，这催生出了需求前端框架和打包工具，比如 webpack、repack 和 vite 等。

前端构建的资源最终是部署到服务器，然后被浏览器请求加载，因此打包策略的不同也会对前端性能造成不小的影响。这也就是为什么像 webpack 这些打包工具都会提供压缩、Tree-Shaking 、代码分割等功能。

其实严谨的来说，构建层影响的是网络传输，应该被归类到网络传输层，但是考虑前端工程化的多样性和复杂性，除了前面所说常见的压缩、代码分割和 tree-shaking 外，还可能涉及到微前端等复杂的领域，因此独立作为第一层，因为这是前端交互的起点。

总结来说，构建层核心目标是尽可能地减少资源的体积。

## 网络传输层

当用户打开一个页面时，浏览器会自动发起对应 HTML 文件的请求，浏览器中的 HTML 解析器首先会加载并解析 HTML 文件，构建成 DOM，与此同时 HTML 解析器和预解析器还会加载 HTML 中声明或 Script 中 JS 动态创建的资源（CSS、JS 、音视频等）。

即使在构建层已经尽量压缩了资源的体积，但是如果网络传输中存在网络延迟过高等问题，也依然会影响系统性能，因此网络传输层也是我们关注的重点。可以通过 TTFB 等指标来分析网络传输层的性能，我们可以通过 CDN、HTTP 缓存、keep-alive长链接等手段来优化这一层的性能问题。

除了网络方面的问题外，从前端的角度来看，需要额外关注两点：
1. 队头阻塞
2. 减少不必要、重复的请求

前者可以借助 HTTP 2 和请求队列等方式优化，后者则可以借助节流和防抖等技术缓解。

总结来说，网络传输层优化的本质，就是**提高网络传输速度、缓解队头阻塞问题、减少不必要的重复请求**。
## 应用加载层

当 HTML 被转换成 DOM 后，浏览器中的渲染引擎协调主线程、合成线程和 GPU 共同作用将 DOM 转换成屏幕中的像素，这个步骤称为渲染管线。渲染管线具体流程可以参考[[深入浏览器引擎 III：Chromium分层合成 vs Firefox WebRender的GPU革命]]

应用加载层包括了：
1. HTML 的加载
2. HTML 的解析
3. 首次渲染

HTML 加载、解析流程可以参考[[深入浏览器引擎 II：HTML 解析全流程——从字节流到 DOM 构建]]

应用加载层优化的核心在于**首屏加载策略**，可以通过 LCP、FCP 等性能指标进行评价分析。

## 运行时

当应用加载完毕且完成首次渲染后，就可以认为进入了运行时阶段。浏览器存在有一个执行栈和事件循环模型，这是 JS 执行和渲染的基石，事件循环模型每个周期都会检测是否需要重新渲染，当用户与页面进行交互时，可能会触发重新渲染，则会重新前面的渲染管线中的操作，不过不需要重新加载 HTML。

运行时的主要瓶颈在于主线程和渲染管线，主线程除了执行 JS 外还负责 GC 和渲染的部分任务，因此如果长任务阻塞主线程，那么就很容易造成丢帧卡顿。另一个瓶颈在于渲染管线，渲染管线是由主线程、合成线程和 GPU 共同完成的，即使主线程未被阻塞，大量重复渲染也依然可能影响合成线程和 GPU 的性能，从而导致卡顿。

### 主线程

JS 是单线程模型

主线程优化的核心在于避免主线程阻塞

### 渲染管线

渲染管线优化的核心在于减少重复无用的渲染
### 内存管理

由于 JS 引擎会自动进行垃圾回收，并没有暴露手动内存分配与回收的相关 API，因此内存问题也很容易被忽略，但是一旦发生内存问题，那么影响也会很大，例如内存泄露很容易导致页面崩溃，影响用户体验。

常见的前端内存问题有三类：
- 内存泄漏
- 栈溢出
- 堆溢出

内存泄漏

## 底层优化层

在这一层中，你需要深入理解更加底层的知识才能进行更好的优化，可以简单的划分成两层：
- 框架层
- JS 层
### 框架层

深入理解框架底层可以帮忙我们写出性能更好的代码，例如对于 Vue 和 React 这些基于虚拟 DOM 的框架，列表节点通常建议采用唯一固定值作为列表元素的 key 值，这是为了在框架底层进行 diff 时来标识节点，以 Vue3 为例，有 key 和没有 key 两种场景下 Vue 采用的策略完全不一样，性能上也有较大差异。

|       | 策略  | 性能            |
| ----- | --- | ------------- |
| 有 key |     | 接近 O (n)      |
| 无 key |     | 最坏情况是 O (n^2) |

### JS 层
JS 是一个弱类型的解释型语言，通过 JS 引擎来优化、执行，常见的 JS 引擎如下所示：

|              | 地位                     | 应用              |
| ------------ | ---------------------- | --------------- |
| SpiderMonkey | 世界上第一个 JavaScript 引擎   | Firefox 浏览器     |
| V8           | 当前应用最广泛的 JavaScript 引擎 | Chromium、Nodejs |
深入了解 JS 引擎能够帮助开发者在极端性能场景下找到优化突破口，其中隐藏类（Hidden Classes）便是 JS 引擎普遍采用的关键优化手段。简单来说，隐藏类是 JS 引擎在运行时为对象动态创建的内部数据结构，它的核心作用是将动态的 JavaScript 对象 “静态化”，从而让引擎能够像处理静态类型语言（如 Java、C++）中的对象一样高效地访问属性。具体可以参考[[深入JavaScript II：从JS引擎看JS的运行与优化]]

以一个例子来对比隐藏类优化生效和未生效两种情况下的性能：

```js
// ✅ 稳定结构，隐藏类可优化
function createStable() {
    return {a: 1, b: 2};
}

// ❌ 动态结构，隐藏类未生效
function createUnstable() {
    const obj = {};
    obj.a = 1;
    obj.b = 2;
    obj.c = 3
    delete obj.c
    return obj;
}

// 测试函数
function test(obj) {
    for (let i = 0; i < 10e7; i++) {
        obj.a = i;
    }
}

// === 性能测试 ===
console.time('稳定隐藏类');
test(createStable());
console.timeEnd('稳定隐藏类');
// 稳定隐藏类: 70.7470703125 ms

console.time('不稳定隐藏类');
test(createUnstable());
console.timeEnd('不稳定隐藏类');
// 不稳定隐藏类: 361.491943359375 ms
```

两者执行所消耗的时间相差足足有五倍，并且随着数据量的增多，两者的性能差异会越来越大。

## 用户体验与业务层

前面五层偏向技术，而最后一层注重的是用户体验与业务关联的优化。

### 用户体验
前端是离用户最近的开发，因此前端不能仅仅关注技术上的性能优化，对于前端而言，有一些可以提高用户感知的性能优化方法，这类方法虽然不能够在客观上提高性能，但是可以在用户主观上提高用户体验和性能感知，让用户“感觉加载速度比较快了”。

常见的技术有：
- 骨架屏
- loading
- 占位图
- 首屏优先渲染
### 业务相关



## 总结

通过前端性能优化六层模型，可以了解前端性能优化不同层面的瓶颈，